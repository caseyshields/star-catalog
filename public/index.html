<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Fundamental Catalog 6</title>
        <!-- <link href="../site.css" rel="stylesheet" /> -->
        <style>
            .overlay * {
                stroke: white;
                fill: white;
                color: white;
            }
            .graticule {
                stroke: grey;
                fill: none;
            }
            .overlay {
                position: absolute;
                top: 5%;
                left: 5%;
            }
            svg {
                pointer-events:all;
                background: black;
                /* position: absolute;
                left: 0;
                top: 0;
                z-index: -1; */
            }
        </style>
    </head>
    <body>
        <div class="overlay">
            <h1> Fundamental Catalog 6 </h1>
            <h4 id='cursor'></h4>
            <h4 id='info'></h4>
            <!-- <h4> brightness threshold:<input type="range" value="0.1" min="0.0" max="1.0" onchange="adjust(this.value)" step="0.01"></h4> -->
            <!-- <h4> Field of View:<input type="range" value="120" min="1" max="179" onchange="fov(this.value)" step="5"></h4> -->
        </div>
        <section>
            <svg width="512" height="512"></svg>
        </section>
        <h6> Philip Plewa pretty much had already done <a href="https://bl.ocks.org/pmplewa/0e36cce6c9c5edb31e18d41ad1f82c4e">exactly what I wanted</a>, so I heavily borrowed from him. He's also doing cool stuff <a href="http://pmplewa.github.io/">tracking stars in the galactic center</a>!</h6>
        
        <script src="https://d3js.org/d3.v5.js"></script>
        <script>
            let svg = d3.select('svg');
            let cursor = d3.select('#cursor');
            let info = d3.select('#info');
            let catalog = null; // the FK6 catalog to be rendered
            let w = svg.attr('width');
            let h = svg.attr('height');

            let dragStart = null; // used for calculating drag vector for setting the rotation

            // define a scale for visual magnitude
            let magnitudeScale = d3.scaleLinear()
                .range( [1,5] );

            // we need to map celestial coordinates to lon/lat 
            rightAscensionScale = d3.scaleLinear()
                .domain([0, 24])
                .range([0,360]);
            // declinationScale = d3.scaleLinear()
            //     .domain([0, 90])
            //     .range([0,90]);

            var lambda = d3.scaleLinear()
                .domain([-w, w])
                .range([-180, 180]);
    
            var phi = d3.scaleLinear()
                .domain([-h, h])
                .range([90, -90]);

            // a stereographic projection is how stars would map to a plane if you were looking from inside the sphere.
            // in this case we are using a celestial sphere instead of terrestrial one
            let stereographic = d3.geoStereographic()
                .translate( [w/2, h/2] )
                .scale( w )
                .clipAngle(90);

            let path = d3.geoPath()
                .projection( stereographic );

            // add a path the draw the sphere's marking under the star field
            svg.append('path')
                .attr('class', 'graticule' )
                .datum( d3.geoGraticule() );

            svg.append('path')
                .attr('class', 'latitude')
                .attr('class', )
            
            // add a group to put the stars in and make a selection for subsequent elelments
            let stars = svg.append('g')
                .attr('class', 'stars')
                .selectAll('circle');

            // load our data set
            d3.json("stars.json").then(function(fk6) {
                catalog = fk6;

                // convert arc hour, minute, seconds to degrees
                for (star of catalog) {
                    star.ra = star.RAh + (star.RAm/60.0) + (star.RAs/3600.0);
                    star.dec = star.DEd + (star.DEm/60.0) + (star.DEs/3600.0);
                    if(star['DE-']=='-')
                        star.dec*=-1;
                    // console.log([star.ra,star.dec]);
                }

                // find range of visual magnitudes
                let range = d3.extent(catalog, (d)=>d.Vmag );
                magnitudeScale.domain( range );
                // console.log( range );

                render();
            });

            svg.call( d3.drag()
                .on('start', started)
                .on('drag', dragged)
                .on('end', ended) );
            svg.on('mousemove', move);

            function render() {

                // draw celestial sphere's lines of ascension and declination
                svg.select('.graticule')
                    .attr('d', path);

                if (!catalog) return;

                // join all star data to stars in our dom
                stars = stars.data( catalog );

                // remove filtered stars from the dom
                stars.exit().remove();

                stars = stars.enter()
                    .append('circle')
                        .style('fill', 'white')
                        .on('click', click )
                    .merge( stars )
                        .attr('r', function(d) {return Math.round( magnitudeScale(d.Vmag) );} );

                stars.each( function(d) {
                    let lon = rightAscensionScale(d.ra)
                    let S = stereographic( [lon, d.dec] );
                    // console.log( S );
                    d3.select(this)
                        .attr('cx', S[0])
                        .attr('cy', S[1]);
                } );
                
            }

            // clicking a star causes it's data to be displayed
            function click(star) {
                if (star) info.html( JSON.stringify( star, null, '<br>') );
                else info.html('');
            }

            // update the cursor information with where the mouse is ointing in the projection
            function move() {
                // get the location of the cursor in the SVG element
                Ps = d3.mouse(this);
                Pw = stereographic.invert( Ps )
                Pc = [ rightAscensionScale.invert(Pw[0]), Pw[1] ];
                cursor.html( JSON.stringify( Pc ) );
            }

            // these drag callbacks update a rotation applied to the projection
            function started() { dragStart = d3.mouse(this); }
            function dragged() {
                // get coordinates of mouse event in svg container
                let dragEnd = d3.mouse(this);

                // abort if this is the first point of the drag
                if(!dragStart) { dragStart = dragEnd; return; }

                // get the distance dragged on the screen
                Dx = lambda( dragEnd[0]-dragStart[0] );
                Dy = phi( dragEnd[1]-dragStart[1] );

                // add it to the current transformation
                let last = stereographic.rotate();
                last = [last[0] + Dx, last[1] + Dy];

                // update the projection
                stereographic.rotate( last );
                render();

                // update the drag point
                dragStart = dragEnd;
            }
            function ended() { dragStart = null; }

            // TODO the mouse wheel should adjust the field of view
            function wheel(angle) {
                stereographic.scale( angle );
                render();
            }

        </script>
    </body>
</html>